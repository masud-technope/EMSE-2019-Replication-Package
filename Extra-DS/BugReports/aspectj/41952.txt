XLint warning for call PCD's using subtype of defining type
Some would like an XLint compiler warning when the user in a call PCD specifies a declaring type that is not the defining type, because that constrains the join points to those whose bytecode signature contain the specified type as the declaring type. e.g., ---- class A { void run() {} } class B extends A {} aspect C { before() : call(void B.run()) { } // warn here } public class Main { public static void main(String[] args) { // ok with -1.4; otherwise, becomes A.run in bytecode new B().run(); // never works - compile-time type of reference is A, not B ((A) new B()).run(); } ---- This warning is useful for two reasons. First, the user probably intended that any call to an instance of that object be picked out (regardless of the compile-time type of the reference used to make the call), and thus should use target(B) && call(void run()) (This suggestion could be in the XLint message.) Second, older compilers (i.e., compilers not using -1.4) would incorrectly specify the declaring type of the method call as the first type in the hierarchy which defined the method, so even if the user meant to constrain the join point by the compile-time reference type, the bytecode signature could be incorrect and the pointcut fail to pick out the join point. One problem with this XLint warning is that is also picks out valid declare warning/error statements enforcing requirements at compile-time about the type of the reference used to invoke a method (e.g., when using a static reference of the wrong type). So perhaps the default level should be ignore. See also bug 41888.