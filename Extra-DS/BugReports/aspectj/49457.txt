No error on overloaded pointcuts unless binding variables
The compiler might not be detecting overloaded pointcut names when parameters are not bound, and/or might not be implementing the pointcut correctly. Below is the context from my reply to Ron Bodkin on aspectj-dev "Proper behavior of overloaded pointcut definitions". (I have not checked this code recently or submitted a test case, nor have I evaluated whether my code below actually replicates Ron's bug.) ---- context from the email The programming guide says, It is an error for two pointcuts to be named with the same name in the same class or aspect declaration. When I compile with overloaded pointcut names, I do get an error. pointcut pc(Runnable r) : target(r) && call(void run()); pointcut pc(SubRunnable r) : target(r) && call(void run()); $ aspectj-1.1.1 -classpath $ajrt11 OverloadedPointcut.java ...\OverloadedPointcut.java:14 duplicate pointcut name: pc ...\OverloadedPointcut.java:15 duplicate pointcut name: pc ... When I use these pointcuts with bound parameters, I get an error. before(Runnable r) : pc(r) { log("pc(Runnable r)"); } before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); } When I use these pointcuts with type parameters, I get no errors. before() : pc(Runnable) { log("pc(Runnable)"); } before() : pc(SubRunnable) { log("pc(SubRunnable)"); } before() : pc(*) { log("pc(*)"); } [...] ---- my code public class OverloadedPointcut { public static void main(String[] args) { new C().run(); } } class C { public void run() {} } aspect A { declare parents: C implements Runnable; declare parents: C implements SubRunnable; interface SubRunnable extends Runnable {} pointcut pc(Runnable r) : target(r) && call(void run()); pointcut pc(SubRunnable r) : target(r) && call(void run()); before(Runnable r) : pc(r) { log("pc(Runnable r)"); } before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); } before() : pc(Runnable) { log("pc(Runnable)"); } before() : pc(SubRunnable) { log("pc(SubRunnable)"); } before() : pc(*) { log("pc(*)"); } void log(String s) { System.out.println(s); } } ---- Ron's code [...] the following program compiles with no warnings, produces no output when run under AspectJ 1.1.1. It appears to behave as if the more specific definition is the only definition of the pointcut [...] Here is a simple program that illustrates the question and odd behavior: package lib; public class RunnablePointcuts { public pointcut runnableCalls(Runnable runnable, Object caller) : call(* run(..)) && target(runnable) && this(caller); //public pointcut specialRunnableCalls(SpecialRunnable runnable, Object caller) : public pointcut runnableCalls(SpecialRunnable runnable, Object caller) : call(* run(..)) && target(runnable) && this(caller); } --- package lib; public interface SpecialRunnable extends Runnable { } --- package client; import lib.RunnablePointcuts; import lib.SpecialRunnable; public aspect Use { before(Object caller) : RunnablePointcuts.runnableCalls(*, caller) && target(MyRunnable) { System.out.println("my runnable called from "+caller); } public static void main(String args[]) { Use.aspectOf().doIt(); } public void doIt() { new MyRunnable().run(); } } // the advice will run if you make this implement SpecialRunnable //class MyRunnable implements SpecialRunnable { class MyRunnable implements Runnable { public void run() {} }